# 1. 浏览器是如何获取到资源的
    1. 确定目标服务器的IP地址
    2. 和该服务建立链接     (TCP 三次握手)
    3. 和该服务器进行数据传输
    4. 和该服务器断开连接   （TCP 四次挥手）


# 2. IP协议 （确定目标服务器的IP地址）
    - DNS解析
        1. 向本地域名服务器询问 www.baidu.com 对应的IP是多少
        2. 向根域名服务器（root）询问  xxx
        3. 向顶级（.com）域名服务器询问  xxx
        4. 向 baidu.com 域名服务器询问  xxx
<img src="D:\workSoftware\typora\workspace\图片\Pasted image 20231222164135.png" alt="Pasted image 20231222164135" style="zoom: 67%;" />

# 3. UDP协议
    1. 面向无连接的
    2. 只是数据报文的搬运工
    3. 不保证有序且不丢失
    4. 没有控制流量的算法（拥塞控制）
    
    - 面向无连接
        不需要向tcp一样建立连接，想发数据就可以直接发
    
    - 不可靠性
        1. 无连接
        2. 拿到什么数据有传输什么数据，也不备份，也不关系对象是否已经明确接收到
        3. 网络环境时好时坏，UDP没有堵塞控制，一直以一个恒定的速度发送数据，
           一旦网络环境差，就很容易发生数据包丢失
        
    - 高效性
        UDP头只有8字节，很小，没有其他复杂的操作，传输效率高，在一些实时性要求高的场景中被使用

# 4. TCP协议
    1. 面向有连接的
    2. 在传输的过程中，通过各种算法保证了数据的可靠性
    3. 有拥塞控制
    
    - 头部标记：
        Sequence number: 序号，接收端可根据这个序号来拼接报文
        Acknowledgement Number: 表示接受端期望接收到的下一个字节编号是多少
        Window Size: 还能接受多少字节的数据，用于流量控制
        标识符：
            URG=1   紧急数据，传输的优先级最高
            ACK=1   确认编号字段有效
            PSH=1   接收端应该立即将接收到的数据提交给应用层使用
            RST=1   PCT链接出现问题，需要重连
            SYN=1 && ACK=0  请求报文    SYN=1 && ACK=1  应答报文
            FIN=1   数据传输完毕，释放连接

# 5. 三次握手

    - 为什么两次握手不够？
        假设客户端向服务端发送一个建立连接请求A，因为网络原因A没有被服务端接收到，
        那么TCP会启用超时重传机制，重新发送建立连接的请求B，当B被服务端接收到且
        服务端应答后，就开始数据传输，然后断开连接。如果断开连接后，请求A又抵达了服务端，
        那么服务端会误以为是客户端和它建立连接，于是会再次应答，且变更自己的状态，
        可是客户端已经closed，那么服务端状态一直等待，带来了资源浪费

# 6. 四次挥手（断开连接）
        1. 客户端向服务端发送释放连接的请求
        2. 服务端将还没有传输完的数据继续传输
        3. 服务端向客户端发送释放连接的应答
        4. 客户端向服务端发送确认应答（2MSL 后进入CLOSED状态）
    
    - 为什么客户端一定要进入TIME_WAIT状态？2MSL 存在的意义？
        为了保证服务端一定能收到客户端的应答，如果客户端发完确认应答后直接进入CLOSED状态，
        一旦网络环境不好，服务端没有接收到应答，服务端就无法关闭，造成资源浪费

# 7. 回流重绘
    输入url到页面渲染 （后半段）
    - 页面加载过程发生了什么 ？
        1. DNS 域名解析。
        2. 建立 TCP 连接（三次握手）。
        3. 发送 HTTP 请求。
        4. 服务器端处理请求。
        5. 返回响应结果。
        6. 关闭 TCP 连接（四次挥手）。
        7. 浏览器解析 HTML。
        8. 浏览器页面布局渲染。
    
    - 浏览器获取到页面资源后做了什么 （7，8）
        1. 浏览器加载HTML代码，将其解析为 DOM 树
        2. 加载 CSS 代码， 将其解析为 CSSOM 树
        3. DOM Tree + CSSOM Tree = Render Tree
    
        4. 计算布局，render树中的每一个节点都会计算一遍（回流）
        5. GPU 绘制 一个又一个图层（重绘）(每个div都相当于一个图层)


    **Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）**
    **Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素生成渲染树**
    
    - 什么时候会发生回流呢？
        1. 视窗大小变化
        2. DOM几何属性发生变化
        3. 添加或者删除DOM
        4. offsetWidth, offsetHeight...,clientWidth...,scrollTop...
    
        - 局部回流
    
        - 回流需要更新渲染树， 性能开销大
    
    - 什么时候会发生重绘呢？
    元素的非几何属性变化时会发生重绘
    1. color
    2. bgc
    3. border-radius
    4. box-shadow
    5. 背景图
    ...
    
    **回流一定会触发重绘，而重绘不一定会回流**
    
    - 浏览器的渲染队列
    
        浏览器维护了一个渲染队列，当我们修改了元素的几何属性，导致浏览器发生回流和重绘时，
        浏览器会将该操作存进队列，等待队列中的内存到达一定的阈值，或者到了一定时间时，浏览器
        会一次性批量操作
    
    - 强制刷新队列
    offsetTop、offsetLeft、offsetWidth、offsetHeight
    scrollTop、scrollLeft、scrollWidth、scrollHeight
    clientTop、clientLeft、clientWidth、clientHeight
    getComputedStyle()
    getBoundingClientRect
    以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。


    - 优化
    1. 当一个dom节点display:none 时，它边不参加render树的构建 display:block
    2. 页面添加额外结构时，使用虚拟文档片段
    3. 使用克隆元素

